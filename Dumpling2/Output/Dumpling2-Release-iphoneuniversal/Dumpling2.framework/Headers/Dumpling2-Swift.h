// Generated by Apple Swift version 3.0.1 (swiftlang-800.0.58.6 clang-800.0.42.1)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import Foundation;
@import ObjectiveC;
#endif

#import <Dumpling2/Dumpling2.h>

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"

/**
  A protocol for managing access control to various purchases
*/
SWIFT_PROTOCOL("_TtP9Dumpling213AccessControl_")
@protocol AccessControl
/**
  This method makes an in-app purchase and calls the Subscriber API to verify if the purchase receipt is valid or not. If valid, the content is unlocked and made available to the user
  \param object Object which has to be purchased. Can be an Article, Volume or Issue object

*/
- (void)purchaseItem:(id _Nonnull)object;
/**
  This method restores all in-app purchases for the current logged in user. If any issues purchased are not available, they will be downloaded, saved to the database and made available. This method checks both in-app purchases as well as web purchases (if userId is not nil)
  :brief: Restore IAPs, save to database
  \param userId User id for which web purchases should be checked. This param is optional. If nil, web purchases will not be checked for

*/
- (void)restorePurchases:(id _Nullable)userId;
/**
  This method retrieves all web purchases for the user whose id is passed. If any issues purchased are not available, they will be downloaded, saved to the database and made available
  :brief: Retrieve web purchases, save to database
  \param userId User id for which web purchases should be checked

*/
- (void)restoreWebPurchases:(id _Nonnull)userId;
/**
  This method checks if a user has access to a given issue (based on Apple id/SKU). If the userId is provided, the app will check for access permissions through both in-app purchase and web purchases. Otherwise it will only check against in-app purchases
  :brief: Check if user has access to a specific issue/article
  :return: true if the user has access to the SKU, false otherwise
  \param appleId SKU for which access needs to be checked

  \param userId User id for which web purchase should be checked

*/
- (BOOL)isAvailable:(NSString * _Nonnull)appleId userId:(id _Nullable)userId;
/**
  This method returns an array of skus for Purchases made by the current logged in user (or IAPs + web purchases if userId is not nil)
  :return: Array of SKUs which the user has access to
  \param userId User id for which purchases should be retrieved

*/
- (NSArray<NSString *> * _Nullable)listPurchases:(id _Nullable)userId;
/**
  This method syncs all purchases saved in the database to the server for given user identity. All purchases which do not have a user id (i.e. have been purchased on the device through IAPs) will also be marked as purchased by this user on the server
  \param userId User id for which purchases should be synced with the server

*/
- (void)syncPurchases:(id _Nonnull)userId;
@end

@class NSString;
@class IssueHandler;

/**
  A model object for Articles
*/
SWIFT_CLASS("_TtC9Dumpling27Article")
@interface Article : RLMObject
/**
  Global id of an article - this is unique for each article
*/
@property (nonatomic, copy) NSString * _Nonnull globalId;
/**
  Article title
*/
@property (nonatomic, copy) NSString * _Nonnull title;
/**
  Article description
*/
@property (nonatomic, copy) NSString * _Nonnull articleDesc;
@property (nonatomic, copy) NSString * _Nonnull slug;
@property (nonatomic, copy) NSString * _Nonnull dek;
/**
  Article content
*/
@property (nonatomic, copy) NSString * _Nonnull body;
/**
  Permanent link to the article
*/
@property (nonatomic, copy) NSString * _Nonnull permalink;
/**
  Article URL
*/
@property (nonatomic, copy) NSString * _Nonnull url;
/**
  URL to the article’s source
*/
@property (nonatomic, copy) NSString * _Nonnull sourceURL;
/**
  Article author’s name
*/
@property (nonatomic, copy) NSString * _Nonnull authorName;
/**
  Link to the article author’s profile
*/
@property (nonatomic, copy) NSString * _Nonnull authorURL;
/**
  Article author’s bio
*/
@property (nonatomic, copy) NSString * _Nonnull authorBio;
/**
  Section under which the article falls
*/
@property (nonatomic, copy) NSString * _Nonnull section;
/**
  Type of article
*/
@property (nonatomic, copy) NSString * _Nonnull articleType;
/**
  Keywords which the article falls under
*/
@property (nonatomic, copy) NSString * _Nonnull keywords;
/**
  Article commentary
*/
@property (nonatomic, copy) NSString * _Nonnull commentary;
/**
  Article published date
*/
@property (nonatomic, copy) NSDate * _Nonnull date;
/**
  Article metadata
*/
@property (nonatomic, copy) NSString * _Nonnull metadata;
@property (nonatomic, copy) NSString * _Nonnull versionStashed;
/**
  Placement of the article in an issue
*/
@property (nonatomic) NSInteger placement;
/**
  URL for the article’s feature image
*/
@property (nonatomic, copy) NSString * _Nonnull mainImageURL;
/**
  URL for the article’s thumbnail image
*/
@property (nonatomic, copy) NSString * _Nonnull thumbImageURL;
/**
  Status of article (published or not)
*/
@property (nonatomic) BOOL isPublished;
/**
  Whether the article is featured for the given issue or not
*/
@property (nonatomic) BOOL isFeatured;
/**
  Global id for the issue the article belongs to. This can be blank for independent articles
*/
@property (nonatomic, copy) NSString * _Nonnull issueId;
/**
  SKU/Apple id for the article - will be used when articles are sold individually
*/
@property (nonatomic, copy) NSString * _Nonnull appleId;
+ (NSString * _Nonnull)primaryKey;
+ (NSArray<NSString *> * _Nonnull)requiredProperties;
/**
  This method accepts an issue’s global id and deletes all articles from the database which belong to that issue
  :brief: Delete articles and assets for a specific issue
  \param issueId The global id of the issue whose articles have to be deleted

*/
+ (void)deleteArticlesFor:(NSString * _Nonnull)issueId;
/**
  This method accepts an issue’s global id, type of article to be found and type of article to be excluded. It retrieves all articles which meet these conditions and returns them in an array.
  All parameters are optional. At least one of the parameters is needed when making this call. The parameters follow AND conditions
  :brief: Get all articles fulfiling certain conditions
  :return: an array of articles fulfiling the conditions sorted by date
  \param issueId The global id of the issue whose articles have to be searched

  \param type The article type which should be searched and returned

  \param excludeType The article type which should not be included in the search

  \param count Number of articles to be returned

  \param page Page number (will be used with count)

*/
+ (NSArray<Article *> * _Nullable)getArticlesFor:(NSString * _Nullable)issueId type:(NSString * _Nullable)type excludeType:(NSString * _Nullable)excludeType count:(NSInteger)count page:(NSInteger)page;
/**
  This method accepts an issue’s global id and the key and value for article search. It retrieves all articles which meet these conditions and returns them in an array.
  The key and value are needed. Other articles are optional. To ignore pagination, pass the count as 0
  :return: an array of articles fulfiling the conditions sorted by date
  \param issueId The global id of the issue whose articles have to be searched

  \param key The key whose values need to be searched. Please ensure this has the same name as the properties available. The value can be any of the Article properties, keywords or customMeta keys

  \param value The value of the key for the articles to be retrieved. If sending multiple keywords, use a comma-separated string with no spaces e.g. keyword1,keyword2,keyword3

  \param count Number of articles to be returned

  \param page Page number (will be used with count)

*/
+ (NSArray<Article *> * _Nullable)getArticlesFor:(NSString * _Nullable)issueId key:(NSString * _Nonnull)key value:(NSString * _Nonnull)value count:(NSInteger)count page:(NSInteger)page;
/**
  This method inputs the global id or Apple id of an article and returns the Article object
  :return: article object for the global/Apple id. Returns nil if the article is not found
  \param articleId The global id for the article

  \param appleId The apple id/SKU for the article

*/
+ (Article * _Nullable)getArticle:(NSString * _Nullable)articleId appleId:(NSString * _Nullable)appleId;
/**
  This method accepts an issue’s global id and returns all articles for an issue (or if nil, all issues) with specific keywords
  :brief: Get all articles for an issue with specific keywords
  :return: an array of articles fulfiling the conditions
  \param keywords An array of String values with keywords that the article should have. If any of the keywords match, the article will be selected

  \param issueId Global id for the issue which the articles must belong to. This parameter is optional

*/
+ (NSArray<Article *> * _Nullable)searchArticlesWith:(NSArray<NSString *> * _Nonnull)keywords issueId:(NSString * _Nullable)issueId;
/**
  This method accepts an issue’s global id and returns all articles for the issue which are featured
  :brief: Get all  featured articles for a specific issue
  :return: an array of featured articles for the issue
  \param issueId Global id for the issue whose featured articles are needed

*/
+ (NSArray<Article *> * _Nullable)getFeaturedArticlesFor:(NSString * _Nonnull)issueId;
/**
  This method accepts a regular expression which should be used to identify placeholders for assets in an article body.
  The default asset pattern is \code
  <!-- \\[ASSET: .+\\] -->
  \endcode
  :brief: Change the asset pattern
  \param newPattern The regex to identify pattern for asset placeholders

*/
+ (void)setAssetPattern:(NSString * _Nonnull)newPattern;
/**
  This method returns all articles whose publish date is before the published date provided
  :return: an array of articles older than the given date
  \param date The date to compare publish dates with

*/
+ (NSArray<Article *> * _Nullable)getOlderArticles:(NSDate * _Nonnull)date;
/**
  This method returns all articles whose publish date is after the published date provided
  :return: an array of articles newer than the given date
  \param date The date to compare publish dates with

*/
+ (NSArray<Article *> * _Nullable)getNewerArticles:(NSDate * _Nonnull)date;
/**
  This method refreshes the given article by downloading it again
*/
- (void)refreshArticle:(IssueHandler * _Nullable)handler;
/**
  This method deletes a stand-alone article and all assets for the given article
*/
- (void)deleteArticle;
/**
  This method downloads assets for the article
*/
- (void)downloadArticleAssets:(IssueHandler * _Nullable)delegate;
/**
  This method downloads assets for the article
*/
- (void)downloadFirstAsset:(IssueHandler * _Nullable)delegate;
/**
  This method can be called on an Article object to save it back to the database
  :brief: Save an Article to the database
*/
- (void)saveArticle;
/**
  This method replaces the asset placeholders in the body of the Article with actual assets using HTML codes
  Images are replaced with HTML img tags, Audio and Video with HTML audio and video tags respectively
  :brief: Replace asset pattern with actual assets in an Article body
  :return: HTML body of the article with actual assets in place of placeholders
*/
- (NSString * _Nonnull)replacePatternsWithAssets;
/**
  This method returns all articles for an issue whose publish date is newer than the published date of current article
  :brief: Get all articles newer than a specific article
  :return: an array of articles newer than the current article (in the same issue)
*/
- (NSArray<Article *> * _Nullable)getNewerArticles;
/**
  This method returns all articles for an issue whose publish date is before the published date of current article
  :brief: Get all articles older than a specific article
  :return: an array of articles older than the current article (in the same issue)
*/
- (NSArray<Article *> * _Nullable)getOlderArticles;
/**
  This method returns the value for a specific key from the custom metadata of the article
  :brief: Get value for a specific key from custom meta of an article
  :return: an object for the key from the custom metadata (or nil)
*/
- (id _Nullable)getValue:(NSString * _Nonnull)key;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithValue:(id _Nonnull)value OBJC_DESIGNATED_INITIALIZER;
@end


/**
  Starter class which adds independent articles to the database
*/
SWIFT_CLASS("_TtC9Dumpling214ArticleHandler")
@interface ArticleHandler : NSObject
/**
  Initializes the ArticleHandler with the given folder. This is where the database and assets will be saved. The method expects to find a key \code
  ClientKey
  \endcode in the project’s Info.plist with your client key. If none is found, the method returns a nil
  \param folder The folder where the database and downloaded assets should be saved

*/
- (nullable instancetype)initWithFolder:(NSString * _Nonnull)folder OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the ArticleHandler with the Documents directory. This is where the database and assets will be saved. The API key is used for making calls to the Magnet API
  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithClientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the ArticleHandler with a custom directory. This is where the database and assets will be saved. The API key is used for making calls to the Magnet API
  \param folder The folder where the database and downloaded assets should be saved

  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithFolder:(NSString * _Nonnull)folder clientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
/**
  The method uses the global id of an article, gets its content from the Magnet API and adds it to the database
  :brief: Get Article details from API and add to database
  \param globalId The global id for the article

*/
- (void)addArticleFromAPI:(NSString * _Nonnull)globalId;
/**
  The method uses the global id of an article and its issue’s global id, gets its content from the Magnet API and adds it to the database
  \param globalId The global id for the article

  \param issueId The global id for the issue

*/
- (void)addArticleFromAPI:(NSString * _Nonnull)globalId issueId:(NSString * _Nonnull)issueId;
/**
  The method uses an SKU/Apple id of an article, gets its content from the Magnet API and adds it to the database
  \param appleId The Apple id for the article

*/
- (void)addArticleWith:(NSString * _Nonnull)appleId;
/**
  This method accepts a property name, its corresponding values and retrieves a paginated list of articles from the API which match this. If either of property or value are blank, the normal addAllArticles method will be invoked
  \param property The property by matching which articles need to be retrieved

  \param value The value of the property

  \param page Page number of articles to fetch. Limit is set to 20. Pagination starts at 0

  \param limit Parameter accepting the number of records to fetch at a time. If this is set to 0, we will fetch 20 records by default

*/
- (void)addArticlesFor:(NSString * _Nonnull)property value:(NSString * _Nonnull)value page:(NSInteger)page limit:(NSInteger)limit;
/**
  The method lets you download and add all articles to the database
  \param page Page number of articles to fetch. Limit is set to 20. Pagination starts at 0

  \param limit Parameter accepting the number of records to fetch at a time. If this is set to 0, we will fetch 20 records by default

*/
- (void)addAllArticles:(NSInteger)page limit:(NSInteger)limit;
/**
  The method lets you download and add all preview articles to the database
  \param page Page number of articles to fetch. Limit is set to 20. Pagination starts at 0

  \param limit Parameter accepting the number of records to fetch at a time. If this is set to 0, we will fetch 20 records by default

*/
- (void)addPreviewArticles:(NSInteger)page limit:(NSInteger)limit;
/**
  The method lets you download and add all published articles to the database
  \param page Page number of articles to fetch. Limit is set to 20. Pagination starts at 0

  \param limit Parameter accepting the number of records to fetch at a time. If this is set to 0, we will fetch 20 records by default

*/
- (void)addAllPublishedArticles:(NSInteger)page limit:(NSInteger)limit;
/**
  Get paginated articles (array) from the database
  :return: Array of independent articles (without any issueIds)
  \param page Page number for results (starts at 0)

  \param count Number of items to be returned (specify as 0 if you need all articles)

*/
- (NSArray<Article *> * _Nullable)getAllArticles:(NSInteger)page count:(NSInteger)count;
- (Article * _Nullable)getArticle:(NSString * _Nonnull)articleId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class Issue;

/**
  A model object for Assets
*/
SWIFT_CLASS("_TtC9Dumpling25Asset")
@interface Asset : RLMObject
/**
  Global id of an asset - this is unique for each asset
*/
@property (nonatomic, copy) NSString * _Nonnull globalId;
/**
  Caption for the asset - used in the final rendered HTML
*/
@property (nonatomic, copy) NSString * _Nonnull caption;
/**
  Source attribution for the asset
*/
@property (nonatomic, copy) NSString * _Nonnull source;
/**
  File URL for the asset’s square thumbnail
*/
@property (nonatomic, copy) NSString * _Nonnull squareURL;
/**
  File URL for the original asset
*/
@property (nonatomic, copy) NSString * _Nonnull originalURL;
/**
  File URL for the portrait image of the asset
*/
@property (nonatomic, copy) NSString * _Nonnull mainPortraitURL;
/**
  File URL for the landscape image of the asset
*/
@property (nonatomic, copy) NSString * _Nonnull mainLandscapeURL;
/**
  File URL for the icon image
*/
@property (nonatomic, copy) NSString * _Nonnull iconURL;
/**
  Custom metadata for the asset
*/
@property (nonatomic, copy) NSString * _Nonnull metadata;
/**
  Asset type. Defaults to a photo. Can be image, sound, video or custom
*/
@property (nonatomic, copy) NSString * _Nonnull type;
/**
  Placement of an asset for an article or issue
*/
@property (nonatomic) NSInteger placement;
/**
  Folder which stores the asset files - downloaded or unzipped
*/
@property (nonatomic, copy) NSString * _Nonnull fullFolderPath;
/**
  Global id for the article with which the asset is associated. Can be blank if this is an issue’s asset
*/
@property (nonatomic, copy) NSString * _Nonnull articleId;
/**
  Issue object for the issue with which the asset is associated. Can be a default Issue object if the asset is for an independent article
*/
@property (nonatomic, strong) Issue * _Nonnull issue;
/**
  Global id of volume the asset is associated with. Can be blank if this is an issue or article asset
*/
@property (nonatomic, copy) NSString * _Nonnull volumeId;
+ (NSString * _Nonnull)primaryKey;
+ (NSArray<NSString *> * _Nonnull)requiredProperties;
/**
  This method lets you save an Asset object back to the database in case some changes are made to it
  :brief: Save an Asset to the database
*/
- (void)saveAsset;
/**
  This method accepts the global id of an asset and deletes it from the database. The file for the asset is also deleted
  :brief: Delete a specific asset
  \param assetId The global id for the asset

*/
+ (void)deleteAsset:(NSString * _Nonnull)assetId;
/**
  This method uses the global id for an issue and/or article and returns its first image asset (i.e. placement = 1, type = image)
  :brief: Retrieve first asset for an issue/article
  :return: Asset object
  \param issueId The global id for the issue

  \param articleId The global id for the article

  \param volumeId The global id for the volume

*/
+ (Asset * _Nullable)getFirstAssetFor:(NSString * _Nonnull)issueId articleId:(NSString * _Nonnull)articleId volumeId:(NSString * _Nullable)volumeId;
/**
  This method uses the global id for an issue and/or article and returns the number of assets it has
  :brief: Retrieve number of assets for an issue/article
  :return: asset count for the issue and/or article
  \param issueId The global id for the issue

  \param articleId The global id for the article

  \param volumeId The global id of the volume

*/
+ (NSUInteger)getNumberOfAssetsFor:(NSString * _Nonnull)issueId articleId:(NSString * _Nonnull)articleId volumeId:(NSString * _Nullable)volumeId;
/**
  This method uses the global id for an issue and/or article and the assets in an array. It takes in an optional type parameter. If specified, only assets of that type will be returned
  :brief: Retrieve all assets for an issue/article of a specific type
  :return: array of assets following the conditions
  \param issueId The global id for the issue

  \param articleId The global id for the article

  \param volumeId The global id for the volume

  \param type The type of asset. If nil, all assets will be returned

*/
+ (NSArray<Asset *> * _Nullable)getAssetsFor:(NSString * _Nonnull)issueId articleId:(NSString * _Nonnull)articleId volumeId:(NSString * _Nullable)volumeId type:(NSString * _Nullable)type;
/**
  This method inputs the global id of an asset and returns the Asset object
  :brief: Retrieve a specific asset
  :return: asset object for the global id. Returns nil if the asset is not found
  \param assetId The global id for the asset

*/
+ (Asset * _Nullable)getAsset:(NSString * _Nonnull)assetId;
/**
  This method inputs the global id of an issue and/or article and returns all sound assets for it in an array
  :brief: Retrieve all sound files for an article/issue as a playlist/array
  :return: Array of sound asset objects for the given issue and/or article
  \param issueId The global id for the issue

  \param articleId The global id for the article

*/
+ (NSArray<Asset *> * _Nullable)getPlaylistFor:(NSString * _Nonnull)issueId articleId:(NSString * _Nonnull)articleId;
/**
  This method returns the path of the asset file for the current object
  :return: Path of the asset file or nil if not found
*/
- (NSString * _Nullable)getAssetPath;
/**
  This method returns the value for a specific key from the custom metadata of the asset
  :return: an object for the key from the custom metadata (or nil)
*/
- (id _Nullable)getValue:(NSString * _Nonnull)key;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithValue:(id _Nonnull)value OBJC_DESIGNATED_INITIALIZER;
@end


/**
  A model object for Issue
*/
SWIFT_CLASS("_TtC9Dumpling25Issue")
@interface Issue : RLMObject
/**
  Global id of an issue - this is unique for each issue
*/
@property (nonatomic, copy) NSString * _Nonnull globalId;
/**
  SKU or Apple Id for an issue
*/
@property (nonatomic, copy) NSString * _Nonnull appleId;
/**
  Title of the issue
*/
@property (nonatomic, copy) NSString * _Nonnull title;
/**
  Description of the issue
*/
@property (nonatomic, copy) NSString * _Nonnull issueDesc;
/**
  Folder saving all the assets for the issue
*/
@property (nonatomic, copy) NSString * _Nonnull assetFolder;
/**
  Global id of the asset which is the cover image of the issue
*/
@property (nonatomic, copy) NSString * _Nonnull coverImageId;
/**
  Global id of the asset for cover image on iPad
*/
@property (nonatomic, copy) NSString * _Nonnull coverImageiPadId;
/**
  Global id of the asset for cover image on iPad Landscape
*/
@property (nonatomic, copy) NSString * _Nonnull coverImageiPadLndId;
/**
  File URL for the icon image
*/
@property (nonatomic, copy) NSString * _Nonnull iconImageURL;
/**
  Published date for the issue
*/
@property (nonatomic, copy) NSDate * _Nonnull publishedDate;
/**
  Last updated date for the issue
*/
@property (nonatomic, copy) NSString * _Nonnull lastUpdateDate;
/**
  Display date for an issue
*/
@property (nonatomic, copy) NSString * _Nonnull displayDate;
/**
  Custom metadata of the issue
*/
@property (nonatomic, copy) NSString * _Nonnull metadata;
/**
  Global id of the volume to which the issue belongs (can be blank if this is an independent issue)
*/
@property (nonatomic, copy) NSString * _Nonnull volumeId;
+ (NSString * _Nonnull)primaryKey;
+ (NSArray<NSString *> * _Nonnull)requiredProperties;
/**
  This method uses the SKU/Apple id for an issue and deletes it from the database. All the issue’s articles, assets, article assets are deleted from the database and the file system
  :brief: Delete an issue
  \param appleId The SKU/Apple id for the issue

*/
+ (void)deleteIssue:(NSString * _Nonnull)appleId;
/**
  This method returns the Issue object for the most recent issue in the database (sorted by publish date)
  :brief: Find most recent issue
  :return:  Object for most recent issue
*/
+ (Issue * _Nullable)getNewestIssue;
/**
  This method takes in an SKU/Apple id and returns the Issue object associated with it (or nil if not found in the database)
  :brief: Get the issue for a specific Apple id
  :return:  Issue object for the given SKU/Apple id
  \param appleId The SKU/Apple id to search for

*/
+ (Issue * _Nullable)getIssueFor:(NSString * _Nonnull)appleId;
/**
  This method returns all issues for a given volume or if volumeId is nil, all issues
  :return: an array of issues for given volume or all issues if volumeId is nil
  \param volumeId Global id of the volume whose issues have to be retrieved

*/
+ (NSArray<Issue *> * _Nullable)getIssues:(NSString * _Nullable)volumeId;
/**
  This method inputs the global id of an issue and returns the Issue object
  :return: issue object for the global id. Returns nil if the issue is not found
  \param issueId The global id for the issue

*/
+ (Issue * _Nullable)getIssue:(NSString * _Nonnull)issueId;
/**
  This method downloads articles for the issue
*/
- (void)downloadIssueArticles;
/**
  This method downloads assets for the issue (only issue assets, not article assets)
*/
- (void)downloadIssueAssets;
/**
  This method downloads assets for the issue and its articles
*/
- (void)downloadAllAssets;
/**
  This method saves an issue back to the database
  :brief: Save an Issue to the database
*/
- (void)saveIssue;
/**
  This method returns the value for a specific key from the custom metadata of the issue
  :brief: Get value for a specific key from custom meta of an issue
  :return: an object for the key from the custom metadata (or nil)
*/
- (id _Nullable)getValue:(NSString * _Nonnull)key;
/**
  This method returns all issues whose publish date is older than the published date of current issue
  :brief: Get all issues older than a specific issue
  :return: an array of issues older than the current issue
*/
- (NSArray<Issue *> * _Nullable)getOlderIssues;
/**
  This method returns all issues whose publish date is newer than the published date of current issue
  :brief: Get all issues newer than a specific issue
  :return: an array of issues newer than the current issue
*/
- (NSArray<Issue *> * _Nullable)getNewerIssues;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithValue:(id _Nonnull)value OBJC_DESIGNATED_INITIALIZER;
@end

@class NSDictionary;
@class NSArray;

/**
  Starter class which adds issues to the database
*/
SWIFT_CLASS("_TtC9Dumpling212IssueHandler")
@interface IssueHandler : NSObject
/**
  Initializes the IssueHandler with the given folder. This is where the database and assets will be saved. The method expects to find a key \code
  ClientKey
  \endcode in the project’s Info.plist with your client key. If none is found, the method returns a nil
  :brief: Initializer object
  \param folder The folder where the database and downloaded assets should be saved

*/
- (nullable instancetype)initWithFolder:(NSString * _Nonnull)folder OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the IssueHandler with the Documents directory. This is where the database and assets will be saved. The API key is used for making calls to the Magnet API
  :brief: Initializer object
  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithClientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the IssueHandler with a custom directory. This is where the database and assets will be saved. The API key is used for making calls to the Magnet API
  :brief: Initializer object
  \param folder The folder where the database and downloaded assets should be saved

  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithFolder:(NSString * _Nonnull)folder clientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFolder:(NSString * _Nonnull)folder clientkey:(NSString * _Nonnull)clientkey migration:(BOOL)migration OBJC_DESIGNATED_INITIALIZER;
/**
  The method uses the global id of an issue, gets its content from the Magnet API and adds it to the database
  :brief: Get Issue details from API and add to database
  \param appleId The SKU/Apple id for the issue. The method looks for a zip with the same name in the Bundle

*/
- (void)addIssueFromAPI:(NSString * _Nonnull)issueId volumeId:(NSString * _Nullable)volumeId withArticles:(BOOL)withArticles;
/**
  The method gets all issues from the Magnet API for the client key and adds them to the database
*/
- (void)addAllIssues;
/**
  The method gets all issues from the Magnet API for the client key and adds them to the database without articles
*/
- (void)addOnlyIssuesWithoutArticles;
/**
  The method gets preview issues from the Magnet API for the client key and adds them to the database
*/
- (void)addPreviewIssues;
/**
  The method is for testing only. It prints the available issues for a client api key
*/
- (void)listIssues;
/**
  The method searches for an issue with a specific Apple ID. If the issue is not available in the database, the issue will be downloaded from the Magnet API and added to the DB
  :brief: Search for an issue with an apple id
  :return: Issue object or nil if the issue is not in the database or on the server
  \param appleId The SKU/Apple id for the issue

*/
- (Issue * _Nullable)searchIssueFor:(NSString * _Nonnull)appleId;
/**
  Get issue details from database for a specific global id
  :return: Issue object or nil if the issue is not in the database
  \param issueId global id of the issue

*/
- (Issue * _Nullable)getIssue:(NSString * _Nonnull)issueId;
/**
  Downloads all the articles for a given issue
  \param issueId global id of the issue

*/
- (void)downloadArticlesFor:(NSString * _Nonnull)issueId;
/**
  Downloads all assets for a given issue (only issue assets)
  \param issueId global id of the issue

*/
- (void)downloadAssetsFor:(NSString * _Nonnull)issueId;
/**
  Downloads all assets for a given issue including article assets
  \param issueId global id of the issue

*/
- (void)downloadAllAssetsFor:(NSString * _Nonnull)issueId;
/**
  Add an issue on Newsstand
  \param issueId global id of the issue

*/
- (void)addIssueOnNewsstand:(NSString * _Nonnull)issueId;
/**
  Find download % progress for an issue or volume. The method requires either a volume’s global id or an issue’s global id. The issue’s global id should be used only if it is an independent issue (i.e. not belonging to any volume)
  :return: Download progress (in percentage) for the issue or volume
  \param issueId Global id of an issue

  \param volumeId Global id of a volume

*/
- (NSInteger)findDownloadProgress:(NSString * _Nullable)volumeId issueId:(NSString * _Nullable)issueId;
- (NSDictionary * _Nonnull)findAllDownloads:(NSString * _Nonnull)issueId;
/**
  Get issue/volume ids whose download not complete yet
  :return: array with issue/volume ids whose download is not complete
*/
- (NSArray * _Nullable)getActiveDownloads;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


/**
  A model object for Purchases
*/
SWIFT_CLASS("_TtC9Dumpling28Purchase")
@interface Purchase : RLMObject
/**
  Apple id/SKU of the purchase made - article or issue
*/
@property (nonatomic, copy) NSString * _Nonnull appleId;
/**
  Global id of the purchase made - article, issue or volume
*/
@property (nonatomic, copy) NSString * _Nonnull globalId;
/**
  Mode of purchase - Web (could be any - Stripe or any other), IAP
*/
@property (nonatomic, copy) NSString * _Nonnull mode;
/**
  Type of purchase - article, issue or volume
*/
@property (nonatomic, copy) NSString * _Nonnull type;
/**
  Purchase date
*/
@property (nonatomic, copy) NSDate * _Nonnull purchaseDate;
/**
  Expiration date
*/
@property (nonatomic, copy) NSString * _Nonnull expirationDate;
/**
  Identity used for syncing web purchases
*/
@property (nonatomic, copy) NSString * _Nonnull userIdentity;
+ (NSString * _Nonnull)primaryKey;
+ (NSArray<NSString *> * _Nonnull)requiredProperties;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithValue:(id _Nonnull)value OBJC_DESIGNATED_INITIALIZER;
@end


/**
  Class handling purchases
*/
SWIFT_CLASS("_TtC9Dumpling215PurchaseHandler")
@interface PurchaseHandler : NSObject
/**
  Initializes the PurchaseHandler with the given folder. This is where the database and assets will be saved. The method expects to find a key \code
  ClientKey
  \endcode in the project’s Info.plist with your client key. If none is found, the method returns a nil
  \param folder The folder where the database is

*/
- (nullable instancetype)initWithFolder:(NSString * _Nonnull)folder OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the PurchaseHandler with the Documents directory. This is where the database should be
  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithClientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the PurchaseHandler with a custom directory. This is where the database is. The API key is used for making calls to the Magnet API
  \param folder The folder where the database is

  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithFolder:(NSString * _Nonnull)folder clientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
/**
  This method adds a purchase to the database
  \param purchase The Purchase object

*/
- (void)addPurchase:(Purchase * _Nonnull)purchase;
/**
  The method returns an array of purchases made on this device - for a specific user or all purchases
  \param userId The user identity for which purchases are to be retrieved. Pass nil for returning all purchases

*/
- (NSArray<Purchase *> * _Nullable)getPurchases:(NSString * _Nullable)userId;
/**
  This method accepts a Purchase’s key and value for purchase search. It retrieves all purchases which meet these conditions and returns them in an array.
  The key and value are needed. userId is optional
  :return: an array of purchases fulfiling the conditions
  \param key The key whose values need to be searched. Please ensure this has the same name as the properties available

  \param value The value of the key for the purchases to be retrieved

  \param userId The user identity for which purchases are to be retrieved. Pass nil for ignoring this

*/
+ (NSArray<Purchase *> * _Nullable)getPurchasesFor:(NSString * _Nonnull)key value:(NSString * _Nonnull)value userId:(NSString * _Nullable)userId;
/**
  This method accepts a purchase object and returns the associated article, issue or volume object
  :return: corresponding volume, issue or article object or nil if none found
  \param purchase The Purchase object

*/
+ (id _Nullable)getPurchase:(Purchase * _Nonnull)purchase;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


@interface RLMArray (SWIFT_EXTENSION(Dumpling2))
@end


@interface RLMObject (SWIFT_EXTENSION(Dumpling2))
@end


@interface RLMRealm (SWIFT_EXTENSION(Dumpling2))
@end


@interface RLMResults (SWIFT_EXTENSION(Dumpling2))
@end


/**
  Class which helps store and retrieve user reading status
*/
SWIFT_CLASS("_TtC9Dumpling212ReaderHelper")
@interface ReaderHelper : NSObject
/**
  Save current active volume
  \param volumeId Global id of the volume which is currently being viewed. If nil, will remove saved volume

*/
+ (void)saveVolume:(NSString * _Nullable)volumeId;
/**
  Save current active issue
  \param issueId Global id of the issue which is currently being viewed. If nil, will remove saved issue

*/
+ (void)saveIssue:(NSString * _Nullable)issueId;
/**
  Save current active article
  \param articleId Global id of the article which is currently being viewed. If nil, will remove saved article

*/
+ (void)saveArticle:(NSString * _Nullable)articleId;
/**
  Save asset being viewed
  \param assetId Global id of the asset which is currently being viewed. If nil, will remove saved asset

*/
+ (void)saveAsset:(NSString * _Nullable)assetId;
/**
  Save reading status for current article
  \param articleId Global id of the article currently being read

  \param readingPercentage Current position of user in the article in percentage

*/
+ (void)saveReadingPercentageFor:(NSString * _Nonnull)articleId readingPercentage:(float)readingPercentage;
/**
  Get current active volume
  :return: global id of active volume or nil
*/
+ (NSString * _Nullable)retrieveCurrentVolume;
/**
  Get current active issue
  :return: global id of active issue or nil
*/
+ (NSString * _Nullable)retrieveCurrentIssue;
/**
  Get current active article
  :return: global id of active article or nil
*/
+ (NSString * _Nullable)retrieveCurrentArticle;
/**
  Get current active asset
  :return: global id of active asset or nil
*/
+ (NSString * _Nullable)retrieveCurrentAsset;
/**
  Get last saved reading percentage for given article
  :return: progress of given article’s reading in percentage
  \param articleId Global id of article for which reading percentage is to be retrieved

*/
+ (float)getReadingPercentageFor:(NSString * _Nonnull)articleId;
/**
  Get all saved values for current issue, article, asset and reading percent for an article
  :return: a dictionary containing saved values for current issue, article, asset and reading percentage for an article
*/
+ (NSDictionary<NSString *, id> * _Nonnull)getDictionaryForCloud;
/**
  This method saves specific values from a key for current issue, current article, current asset and article reading percentage back to user defaults (for using while app is active)
  :brief: Saves current reading status to User defaults
  \param savedValues a dictionary containing saved values for current issue, article, asset and reading percentage for an article

*/
+ (void)saveDictionaryToUserDefaults:(NSDictionary<NSString *, id> * _Nonnull)savedValues;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/**
  A model object for Volumes
*/
SWIFT_CLASS("_TtC9Dumpling26Volume")
@interface Volume : RLMObject
/**
  Global id of a volume - this is unique for each volume
*/
@property (nonatomic, copy) NSString * _Nonnull globalId;
/**
  Title of the volume
*/
@property (nonatomic, copy) NSString * _Nonnull title;
/**
  Subtitle of the volume
*/
@property (nonatomic, copy) NSString * _Nonnull subtitle;
/**
  Description of the volume
*/
@property (nonatomic, copy) NSString * _Nonnull volumeDesc;
/**
  Folder saving all the assets for the issue
*/
@property (nonatomic, copy) NSString * _Nonnull assetFolder;
/**
  Global id of the asset which is the cover image of the issue
*/
@property (nonatomic, copy) NSString * _Nonnull coverImageId;
/**
  Publisher of the volume
*/
@property (nonatomic, copy) NSString * _Nonnull publisher;
/**
  Published date for the volume
*/
@property (nonatomic, copy) NSDate * _Nonnull publishedDate;
/**
  Release date for the volume
*/
@property (nonatomic, copy) NSString * _Nonnull releaseDate;
/**
  Custom metadata of the volume
*/
@property (nonatomic, copy) NSString * _Nonnull metadata;
/**
  Keywords for the volume
*/
@property (nonatomic, copy) NSString * _Nonnull keywords;
/**
  Whether the volume is published or not
*/
@property (nonatomic) BOOL published;
+ (NSString * _Nonnull)primaryKey;
+ (NSArray<NSString *> * _Nonnull)requiredProperties;
/**
  This method uses the global id for a volume and deletes it from the database. All the volume’s issues, assets, articles, issue assets, article assets are deleted from the database and the file system
  :brief: Delete a volume
  \param globalId The global id for the volume

*/
+ (void)deleteVolume:(NSString * _Nonnull)globalId;
/**
  This method returns the Volume object for the most recent volume in the database (sorted by publish date)
  :brief: Find most recent volume
  :return:  Object for most recent volume
*/
+ (Volume * _Nullable)getNewestVolume;
/**
  This method returns all volumes with specific keywords
  :return: an array of volumes fulfiling the conditions
  \param keywords An array of String values with keywords that the volume should have. If any of the keywords match, the volume will be selected

*/
+ (NSArray<Volume *> * _Nullable)searchVolumesWith:(NSArray<NSString *> * _Nonnull)keywords;
/**
  This method returns all volumes
  :return: an array of volumes
*/
+ (NSArray<Volume *> * _Nullable)getVolumes;
/**
  This method inputs the global id of a volume and returns the Volume object
  :return: Volume object for the global id. Returns nil if the volume is not found
  \param volumeId The global id for the volume

*/
+ (Volume * _Nullable)getVolume:(NSString * _Nonnull)volumeId;
/**
  This method saves a volume back to the database
  :brief: Save a volume to the database
*/
- (void)saveVolume;
/**
  This method returns the value for a specific key from the custom metadata of the volume
  :brief: Get value for a specific key from custom meta of a volume
  :return: an object for the key from the custom metadata (or nil)
*/
- (id _Nullable)getValue:(NSString * _Nonnull)key;
/**
  This method returns all volumes whose publish date is older than the published date of current volume
  :brief: Get all volumes older than a specific volume
  :return: an array of volumes older than the current volume
*/
- (NSArray<Volume *> * _Nullable)getOlderVolumes;
/**
  This method returns all volumes whose publish date is newer than the published date of current volume
  :brief: Get all volumes newer than a specific volume
  :return: an array of volumes newer than the current volume
*/
- (NSArray<Volume *> * _Nullable)getNewerVolumes;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithValue:(id _Nonnull)value OBJC_DESIGNATED_INITIALIZER;
@end


/**
  Starter class which adds volumes to the database
*/
SWIFT_CLASS("_TtC9Dumpling213VolumeHandler")
@interface VolumeHandler : NSObject
/**
  Instance of IssueHandler class
*/
@property (nonatomic, strong) IssueHandler * _Null_unspecified issueHandler;
/**
  Initializes the VolumeHandler with the given folder. This is where the database and assets will be saved. The method expects to find a key \code
  ClientKey
  \endcode in the project’s Info.plist with your client key. If none is found, the method returns a nil
  :brief: Initializer object
  \param folder The folder where the database and downloaded assets should be saved

*/
- (nullable instancetype)initWithFolder:(NSString * _Nonnull)folder OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the VolumeHandler with the Documents directory. This is where the database and assets will be saved. The API key is used for making calls to the Magnet API
  :brief: Initializer object
  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithClientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
/**
  Initializes the VolumeHandler with a custom directory. This is where the database and assets will be saved. The API key is used for making calls to the Magnet API
  :brief: Initializer object
  \param folder The folder where the database and downloaded assets should be saved

  \param clientkey Client API key to be used for making calls to the Magnet API

*/
- (nonnull instancetype)initWithFolder:(NSString * _Nonnull)folder clientkey:(NSString * _Nonnull)clientkey OBJC_DESIGNATED_INITIALIZER;
/**
  Find current schema version
  :return: the current schema version for the database
*/
+ (uint64_t)getCurrentSchemaVersion;
/**
  The method uses the global id of a volume, gets its content from the Magnet API and adds it to the database
  :brief: Get Volume details from API and add to database
  \param globalId The global id for the volume

*/
- (void)addVolumeFromAPI:(NSString * _Nonnull)globalId;
/**
  The method uses the SKU/Apple id of a volume, gets its content from the Magnet API and adds it to the database
  \param appleId The Apple id for the volume

*/
- (void)addVolumeFor:(NSString * _Nonnull)appleId;
/**
  This method gets last 20 volumes for a client key, downloads it and saves it to the database
*/
- (void)addAllVolumes;
/**
  This method gets all available volumes for a client key, downloads it and saves it to the database
  \param page Page number of articles to fetch. Limit is set to 20. Pagination starts at 0

  \param limit Parameter accepting the number of records to fetch at a time. If this is set to 0 or nil, we will fetch 20 records by default

*/
- (void)addAllVolumes:(NSInteger)page limit:(NSInteger)limit;
/**
  Get volume details from database for a specific global id
  :return: Volume object or nil if the volume is not in the database
  \param volumeId global id of the volume

*/
- (Volume * _Nullable)getVolume:(NSString * _Nonnull)volumeId;
- (void)listVolumes;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

#pragma clang diagnostic pop
